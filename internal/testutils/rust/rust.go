package rust

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"testing"

	"github.com/alphabill-org/alphabill-go-base/types"
	"github.com/alphabill-org/alphabill-go-base/types/hex"
)

/*
TestFile creates file with name "filename" in the directory denoted by the
AB_RUST_SDK_ROOT environment variable (ie the filename should be relative to that
path). If the env var is not set (empty) the test "t" will be skipped.

The "src" will be written into the file, ie this can be used to set the file header,
initial module imports etc.

If the file "filename" already exists it will be truncated. The file will be
automatically closed at the end of the test "t".

To generate tests using this function run

	AB_RUST_SDK_ROOT="/path/to/alphabill-rust-predicates-sdk" go test ./...
*/
func TestFile(t *testing.T, filename, src string) *os.File {
	sdkRoot := os.Getenv("AB_RUST_SDK_ROOT")
	if sdkRoot == "" {
		t.Skip("Rust SDK root directory not provided")
	}

	root, err := os.OpenRoot(sdkRoot)
	if err != nil {
		t.Fatal("opening Rust SDK root directory:", err)
	}
	t.Cleanup(func() {
		if err := root.Close(); err != nil {
			t.Log("closing root dir of Rust SDK: ", err)
		}
	})

	fOut, err := root.Create(filename)
	if err != nil {
		t.Fatal("creating file for test:", err)
	}
	fmt.Fprint(fOut, "// this test is generated by Go backend, ", t.Name(), "\n// DO NOT EDIT!\n\n", src, "\n\n")

	t.Cleanup(func() {
		if err := fOut.Close(); err != nil {
			t.Log("closing generated test file: ", err)
		}
		cmd := exec.Command("cargo", "fmt", "--", filename)
		cmd.Dir = sdkRoot
		if err := cmd.Run(); err != nil {
			t.Log("formatting generated file: ", err)
		}
	})

	return fOut
}

/*
Value returns v as Rust SDK Value enum.
*/
func Value(t *testing.T, v any) string {
	t.Helper()
	switch tv := v.(type) {
	case uint32, uint16:
		return fmt.Sprintf("Value::U32(%#x)", tv)
	case uint64:
		return fmt.Sprintf("Value::U64(%#x)", tv)
	case []byte:
		return fmt.Sprintf("Value::Bytes(vec![%s])", BytesAsHex(t, tv))
	case string:
		return fmt.Sprintf("Value::String(%q.to_string())", tv)
	case []any:
		out := "Value::Array(vec!["
		for x, v := range tv {
			if x > 0 {
				out += ", "
			}
			out += Value(t, v)
		}
		return out + "])"
	default:
		t.Errorf("unsupported type %T", v)
		return ""
	}
}

/*
Option returns v as Rust value wrapped to Option.

The zero value of the type (ie 0 for int or "" for string) is encoded
as "None", otherwise as "Some".
For byte slices nil is encoded as None while empty slice is encoded as Some.
*/
func Option(t *testing.T, v any) string {
	t.Helper()
	switch tv := v.(type) {
	case nil:
		return "None"
	case []byte:
		return optionByteSlice(t, tv)
	case hex.Bytes:
		return optionByteSlice(t, tv)
	case types.UnitID:
		if tv == nil {
			return "None"
		}
		return fmt.Sprintf("Some(vec![%s])", BytesAsHex(t, tv))
	case string:
		if tv == "" {
			return "None"
		}
		return fmt.Sprintf("Some(%q.to_string())", tv)
	case uint64:
		if tv == 0 {
			return "None"
		}
		return fmt.Sprintf("Some(%d)", tv)
	default:
		t.Errorf("unsupported type %T", v)
		return ""
	}
}

func optionByteSlice(t *testing.T, b []byte) string {
	switch {
	case b == nil:
		return "None"
	case len(b) == 0:
		return "Some(Vec::new())"
	default:
		return fmt.Sprintf("Some(vec![%s])", BytesAsHex(t, b))
	}
}

/*
byte slice in Rust syntax (without enclosing brackets, ie just values of bytes
separated by comma).
*/
func BytesAsHex(t *testing.T, b []byte) string {
	t.Helper()
	out := bytes.Buffer{}
	for _, v := range b {
		out.WriteString(fmt.Sprintf("0x%x, ", v))
	}
	return strings.TrimSuffix(out.String(), ", ")
}

// Code generated by tygo. DO NOT EDIT.

//////////
// source: attributes.go

export const PayloadTypeCreateNFTType = "createNType";
export const PayloadTypeMintNFT = "createNToken";
export const PayloadTypeTransferNFT = "transNToken";
export const PayloadTypeUpdateNFT = "updateNToken";
export const PayloadTypeCreateFungibleTokenType = "createFType";
export const PayloadTypeMintFungibleToken = "createFToken";
export const PayloadTypeTransferFungibleToken = "transFToken";
export const PayloadTypeSplitFungibleToken = "splitFToken";
export const PayloadTypeBurnFungibleToken = "burnFToken";
export const PayloadTypeJoinFungibleToken = "joinFToken";
export const PayloadTypeLockToken = "lockToken";
export const PayloadTypeUnlockToken = "unlockToken";
export interface CreateNonFungibleTokenTypeAttributes {
  Symbol: string; // the symbol (short name) of this token type; note that the symbols are not guaranteed to be unique;
  Name: string; // the long name of this token type;
  Icon?: Icon; // the icon of this token type;
  ParentTypeID: any /* types.UnitID */; // identifies the parent type that this type derives from; 0 indicates there is no parent type;
  SubTypeCreationPredicate: string; // the predicate clause that controls defining new sub-types of this type;
  TokenCreationPredicate: string; // the predicate clause that controls creating new tokens of this type
  InvariantPredicate: string; // the invariant predicate clause that all tokens of this type (and of sub- types of this type) inherit into their bearer predicates;
  DataUpdatePredicate: string; // the clause that all tokens of this type (and of sub-types of this type) inherit into their data update predicates
  SubTypeCreationPredicateSignatures: string[]; // inputs to satisfy the sub-type creation predicates of all parents.
}
export interface MintNonFungibleTokenAttributes {
  Bearer: string; // the initial bearer predicate of the new token
  NFTTypeID: any /* types.UnitID */; // identifies the type of the new token;
  Name: string; // the name of the new token
  URI: string; // the optional URI of an external resource associated with the new token
  Data: string; // the optional data associated with the new token
  DataUpdatePredicate: string; // the data update predicate of the new token;
  TokenCreationPredicateSignatures: string[]; // inputs to satisfy the token creation predicates of all parent types.
}
export interface TransferNonFungibleTokenAttributes {
  NewBearer: string; // the new bearer predicate of the token
  Nonce: string; // optional nonce
  Backlink: string; // the backlink to the previous transaction with the token
  NFTTypeID: any /* types.UnitID */; // identifies the type of the token;
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface UpdateNonFungibleTokenAttributes {
  Data: string; // the new data to replace the data currently associated with the token
  Backlink: string; // the backlink to the previous transaction with the token
  DataUpdateSignatures: string[]; // inputs to satisfy the token data update predicates down the inheritance chain
}
export interface CreateFungibleTokenTypeAttributes {
  Symbol: string; // the symbol (short name) of this token type; note that the symbols are not guaranteed to be unique;
  Name: string; // the long name of this token type;
  Icon?: Icon; // the icon of this token type;
  ParentTypeID: any /* types.UnitID */; // identifies the parent type that this type derives from; 0 indicates there is no parent type;
  DecimalPlaces: number /* uint32 */; // the number of decimal places to display for values of tokens of the new type;
  SubTypeCreationPredicate: string; // the predicate clause that controls defining new sub-types of this type;
  TokenCreationPredicate: string; // the predicate clause that controls creating new tokens of this type
  InvariantPredicate: string; // the invariant predicate clause that all tokens of this type (and of sub- types of this type) inherit into their bearer predicates;
  SubTypeCreationPredicateSignatures: string[]; // inputs to satisfy the sub-type creation predicates of all parents.
}
export interface Icon {
  type: string; // the MIME content type identifying an image format;
  data: string; // the image in the format specified by type;
}
export interface MintFungibleTokenAttributes {
  Bearer: string; // the initial bearer predicate of the new token
  TypeID: any /* types.UnitID */; // identifies the type of the new token;
  Value: number /* uint64 */; // the value of the new token;
  TokenCreationPredicateSignatures: string[]; // inputs to satisfy the token creation predicates of all parent types.
}
export interface TransferFungibleTokenAttributes {
  NewBearer: string; // the initial bearer predicate of the new token
  Value: number /* uint64 */; // the value to transfer
  Nonce: string;
  Backlink: string; // the backlink to the previous transaction with this token
  TypeID: any /* types.UnitID */; // identifies the type of the token;
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface SplitFungibleTokenAttributes {
  NewBearer: string; // the bearer predicate of the new token;
  TargetValue: number /* uint64 */; // the value of the new token
  Nonce: string;
  Backlink: string; // the backlink to the previous transaction with this token
  TypeID: any /* types.UnitID */; // identifies the type of the token;
  RemainingValue: number /* uint64 */; // new value of the source token
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface BurnFungibleTokenAttributes {
  TypeID: any /* types.UnitID */; // identifies the type of the token to burn;
  Value: number /* uint64 */; // the value to burn
  TargetTokenID: any /* types.UnitID */; // the target token identifier in join step
  TargetTokenBacklink: string; // the current state hash of the target token
  Backlink: string; // the backlink to the previous transaction with this token
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface JoinFungibleTokenAttributes {
  BurnTransactions: (any /* types.TransactionRecord */ | undefined)[]; // the transactions that burned the source tokens;
  Proofs: (any /* types.TxProof */ | undefined)[]; // block proofs for burn transactions
  Backlink: string; // the backlink to the previous transaction with this token
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface LockTokenAttributes {
  LockStatus: number /* uint64 */; // status of the lock, non-zero value means locked
  Backlink: string; // the backlink to the previous transaction with this token
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}
export interface UnlockTokenAttributes {
  Backlink: string; // the backlink to the previous transaction with this token
  InvariantPredicateSignatures: string[]; // inputs to satisfy the token type invariant predicates down the inheritance chain
}

//////////
// source: ft_burn.go


//////////
// source: ft_join.go


//////////
// source: ft_module.go

export interface FungibleTokensModule {
}

//////////
// source: ft_split.go


//////////
// source: ft_transfer.go


//////////
// source: lock_token.go


//////////
// source: lock_tokens_module.go

export interface LockTokensModule {
}

//////////
// source: nft_module.go

export interface NonFungibleTokensModule {
}

//////////
// source: nft_transfer.go


//////////
// source: options.go

export interface Options {
}
export type Option = any;

//////////
// source: predicates.go

export type TokenOwnershipProver = 
    any /* types.SigBytesProvider */;
export type TokenSubtypeCreationProver = 
    any /* types.SigBytesProvider */;
export type TokenCreationProver = 
    any /* types.SigBytesProvider */;
export type NFTDataUpdateProver = 
    any /* types.SigBytesProvider */;

//////////
// source: token_tx_system.go

export const ErrStrInvalidUnitID = "invalid unit ID";
export const ErrStrInvalidTypeID = "invalid type ID";
export const ErrStrInvalidParentTypeID = "invalid parent type ID";
export const ErrStrSystemIdentifierIsNil = "system identifier is nil";
export const ErrStrStateIsNil = "state is nil";
export const ErrStrInvalidSymbolLength = "symbol length exceeds the allowed maximum of 16 bytes";
export const ErrStrInvalidNameLength = "name length exceeds the allowed maximum of 256 bytes";
export const ErrStrInvalidIconTypeLength = "icon type length exceeds the allowed maximum of 64 bytes";
export const ErrStrInvalidIconDataLength = "icon data length exceeds the allowed maximum of 64 KiB";

//////////
// source: unit_data_types.go

export interface NonFungibleTokenTypeData {
  Symbol: string;
  Name: string;
  Icon?: Icon;
  ParentTypeId: any /* types.UnitID */; // identifies the parent type that this type derives from; 0 indicates there is no parent type;
  SubTypeCreationPredicate: string; // the predicate clause that controls defining new sub-types of this type;
  TokenCreationPredicate: string; // the predicate clause that controls creating new tokens of this type
  InvariantPredicate: string; // the invariant predicate clause that all tokens of this type (and of sub-types of this type) inherit into their bearer predicates;
  DataUpdatePredicate: string; // the clause that all tokens of this type (and of sub-types of this type) inherit into their data update predicates
}
export interface FungibleTokenTypeData {
  Symbol: string;
  Name: string;
  Icon?: Icon;
  ParentTypeId: any /* types.UnitID */; // identifies the parent type that this type derives from; 0 indicates there is no parent type;
  DecimalPlaces: number /* uint32 */; // is the number of decimal places to display for values of tokens of this type;
  SubTypeCreationPredicate: string; // the predicate clause that controls defining new sub-types of this type;
  TokenCreationPredicate: string; // the predicate clause that controls creating new tokens of this type
  InvariantPredicate: string; // the invariant predicate clause that all tokens of this type (and of sub-types of this type) inherit into their bearer predicates;
}
export interface NonFungibleTokenData {
  NftType: any /* types.UnitID */;
  Name: string; // the optional long name of the token
  URI: string; // uri is the optional URI of an external resource associated with the token
  Data: string; // data is the optional data associated with the token.
  DataUpdatePredicate: string; // the data update predicate;
  T: number /* uint64 */; // the round number of the last transaction with this token;
  Backlink: string; // the hash of the last transaction order for this token
  Locked: number /* uint64 */; // locked status of the bill, non-zero value means locked
}
export interface FungibleTokenData {
  TokenType: any /* types.UnitID */; // the type of the token;
  Value: number /* uint64 */; // the value of the token;
  T: number /* uint64 */; // the round number of the last transaction with this token;
}

//////////
// source: unit_types.go

export const UnitIDLength = UnitPartLength + TypePartLength;
export const UnitPartLength = 32;
export const TypePartLength = 1;

//////////
// source: unlock_token.go


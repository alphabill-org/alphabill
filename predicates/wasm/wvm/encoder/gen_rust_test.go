package encoder

import (
	"bytes"
	"fmt"
	"strings"
	"sync/atomic"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/alphabill-org/alphabill-go-base/types"
	"github.com/alphabill-org/alphabill/internal/testutils/rust"
)

func Test_TXSystemEncoder_trigger(t *testing.T) {
	/*
		If test here fails it's probably because some data structure (or rather how it's
		serialized for Rust SDK) has been changed without versioning?
		Also, the Rust predicates SDK likely needs to be updated! See the
		other tests here to generate tests for Rust SDK.
	*/

	const partitionID types.PartitionID = 7
	// encoder is stateless, can be shared between tests
	enc, err := New(partitionID)
	require.NoError(t, err)

	t.Run("txRecord", func(t *testing.T) {
		// ver 1 of the txRec just contains txo handle so no need to fill out all the fields...
		// getHandle is called once, always return 1 as the handle
		getHandle := func(obj any) uint32 { return 1 }
		tx, err := (&types.TransactionOrder{Version: 1}).MarshalCBOR()
		require.NoError(t, err)
		buf, err := enc.Encode(&types.TransactionRecord{Version: 1, TransactionOrder: tx}, 1, getHandle)
		require.NoError(t, err)
		require.Equal(t, []byte{0x1, 0x3, 0x1, 0x0, 0x0, 0x0}, buf)
	})

	t.Run("txOrder", func(t *testing.T) {
		getHandle := func(obj any) uint32 { t.Errorf("unexpected call of getHandle(%T)", obj); return 0 }
		// ver 1 of the txOrder
		txo := &types.TransactionOrder{
			Version: 1,
			Payload: types.Payload{
				PartitionID: partitionID,
				Type:        22,
				UnitID:      []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
				ClientMetadata: &types.ClientMetadata{
					ReferenceNumber: []byte("ref-no"),
				},
			},
		}
		buf, err := enc.Encode(txo, 1, getHandle)
		require.NoError(t, err)
		require.Equal(t, []byte{0x1, 0x3, 0x7, 0x0, 0x0, 0x0, 0x2, 0x1, 0xa, 0x0, 0x0, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0x3, 0x3, 0x16, 0x0, 0x0, 0x0, 0x4, 0x1, 0x6, 0x0, 0x0, 0x0, 0x72, 0x65, 0x66, 0x2d, 0x6e, 0x6f}, buf)
	})

	t.Run("byte slice", func(t *testing.T) {
		buf, err := enc.Encode([]byte{0, 1, 127, 128, 255}, 1, nil)
		require.NoError(t, err)
		require.Equal(t, []byte{type_id_bytes, 0x5, 0x0, 0x0, 0x0, 0, 1, 127, 128, 255}, buf)
	})

	t.Run("types.RawCBOR", func(t *testing.T) {
		buf, err := enc.Encode(types.RawCBOR{0, 1, 127, 128, 255}, 1, nil)
		require.NoError(t, err)
		require.Equal(t, []byte{type_id_bytes, 0x5, 0x0, 0x0, 0x0, 0, 1, 127, 128, 255}, buf)
	})

	t.Run("uint64", func(t *testing.T) {
		buf, err := enc.Encode(uint64(0x0807060504030201), 0, nil)
		require.NoError(t, err)
		require.Equal(t, []byte{type_id_u64, 1, 2, 3, 4, 5, 6, 7, 8}, buf)
	})
}

func Test_generate_TXSTestsData(t *testing.T) {
	// generate integration tests for Rust SDK:
	// tests loading generic tx system objects.

	fOut := rust.TestFile(t, "tests/txsystem_test.rs", "use alphabill::txsystem::TxOrder;")

	var hid atomic.Uint32
	getHandle := func(obj any) uint32 { return hid.Add(1) }
	// encoder is stateless, can be shared between tests
	const partitionID types.PartitionID = 7
	enc, err := New(partitionID)
	require.NoError(t, err)

	t.Run("txOrder", func(t *testing.T) {
		txo := &types.TransactionOrder{
			Version: 1,
			Payload: types.Payload{
				NetworkID:   1,
				PartitionID: partitionID,
				Type:        22,
				UnitID:      []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
				ClientMetadata: &types.ClientMetadata{
					ReferenceNumber: []byte("ref-no"),
				},
			},
		}
		buf, err := enc.Encode(txo, 1, getHandle)
		require.NoError(t, err)
		out := bytes.NewBufferString("\n#[test]\nfn txorder_from() {")
		out.WriteString(fmt.Sprintf("\n// Payload: %#v\n// ClientMetadata: %#v\n", txo.Payload, txo.ClientMetadata))
		out.WriteString("// txo version 1 SDK version 1\n")
		out.WriteString(fmt.Sprintf("let data: &mut [u8] = &mut [%s];", rust.BytesAsHex(t, buf)))
		out.WriteString("let txo = TxOrder::from(data).unwrap();\n")
		out.WriteString(fmt.Sprintf("assert_eq!(txo.partition, %d);\n", txo.PartitionID))
		out.WriteString(fmt.Sprintf("assert_eq!(txo.typ, %d);\n", txo.Type))
		out.WriteString(fmt.Sprintf("assert_eq!(txo.unit_id, &[%s]);\n", rust.BytesAsHex(t, txo.UnitID)))
		out.WriteString(fmt.Sprintf("assert_eq!(txo.ref_number.unwrap(), &[%s]);\n", rust.BytesAsHex(t, txo.ReferenceNumber())))
		out.WriteString("}\n")
		_, err = out.WriteTo(fOut)
		require.NoError(t, err)
	})
}

func Test_generateDecoderTests(t *testing.T) {
	// generate integration tests for Rust SDK:
	// test that the Decoder in Rust SDK is able to decode data generated by the TVEnc encoder in host.

	fOut := rust.TestFile(t, "tests/decoder_test.rs", "use alphabill::decoder::{Decoder, TagValueIter, Value};")

	type encValue struct {
		tag   uint8
		value any
	}

	t.Run("Decode Value", func(t *testing.T) {
		// test decoding different types as Value enum defined in the Rust SDK
		values := []encValue{
			{value: uint16(0x0201)},
			{value: uint32(0x04030201)},
			{value: uint64(0x0807060504030201)},
			{value: []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}},
			{value: "this is string"},
			{value: []any{uint32(32), uint64(64), "AB"}},
			// zero values
			{value: ""},
			{value: []byte(nil)},
			{value: []any{}},
		}
		out := bytes.NewBufferString("\n#[test]\nfn decode_value() {")
		for _, v := range values {
			enc := TVEnc{}
			enc.Encode(v.value)
			buf, err := enc.Bytes()
			require.NoError(t, err)
			out.WriteString(fmt.Sprintf("\n// Go value %T = %#[1]v\n", v.value))
			out.WriteString("let data: &mut [u8] = &mut [")
			out.WriteString(rust.BytesAsHex(t, buf))
			out.WriteString("];\n")
			out.WriteString("let mut dec = Decoder::new(data);\n")
			out.WriteString(fmt.Sprintf("assert_eq!(dec.value(), %s);\n", rust.Value(t, v.value)))
		}
		out.WriteString("}\n")
		_, err := out.WriteTo(fOut)
		require.NoError(t, err)
	})

	t.Run("TagValueIter", func(t *testing.T) {
		// test for parsing data sent from host using TagValueIter
		values := []encValue{
			{tag: 3, value: uint16(0xf0f0)},
			{tag: 1, value: uint32(0xff00ff00)},
			{tag: 4, value: uint64(0xff00ff00ff00ff00)},
			{tag: 2, value: "token"},
			{tag: 8, value: []any{uint32(0x87654321), "str"}},
		}
		out := bytes.NewBufferString("\n#[test]\nfn iterator() {")
		enc := TVEnc{}
		rv := []string{}
		for _, v := range values {
			enc.EncodeTagged(v.tag, v.value)
			rv = append(rv, fmt.Sprintf("(%d, %s)", v.tag, rust.Value(t, v.value)))
		}
		buf, err := enc.Bytes()
		require.NoError(t, err)
		out.WriteString("let data: &mut [u8] = &mut [")
		out.WriteString(rust.BytesAsHex(t, buf))
		out.WriteString("];\n")
		out.WriteString("let dec = TagValueIter::new(&data);\nlet items: Vec<(u8, Value)> = dec.collect();\n")
		out.WriteString(fmt.Sprintf("assert_eq!(items, vec![%s]);\n", strings.Join(rv, ", ")))
		out.WriteString("}\n")
		_, err = out.WriteTo(fOut)
		require.NoError(t, err)
	})
}
